import asyncio
import json
import logging
import os

import pytest
import structlog
from jupyter_client import AsyncKernelClient, manager
from kernel_sidecar.client import KernelSidecarClient


@pytest.fixture(scope="session")
def event_loop():
    return asyncio.get_event_loop()


@pytest.fixture(scope="session")
async def ipykernel() -> dict:
    """
    Starts a new ipykernel in a separate process. If you want to manually start an ipykernel
    to see Kernel debug logs or because it's set up as a separate step in CI jobs, set the
    IPYKERNEL_TEST_CONNECTION_FILE env variable to the .json connection file. For example:

    poetry shell
    python -m ipykernel_launcher --debug -f /tmp/kernel.json

    Then run pytest with:

    IPYKERNEL_TEST_CONNECTION_FILE=/tmp/kernel.json pytest
    """
    if "IPYKERNEL_TEST_CONNECTION_FILE" in os.environ:
        yield json.load(open(os.environ["IPYKERNEL_TEST_CONNECTION_FILE"]))
    else:
        km: manager.AsyncKernelManager
        kc: AsyncKernelClient
        km, kc = await manager.start_new_async_kernel()
        try:
            yield kc.get_connection_info()
        finally:
            await km.shutdown_kernel()


@pytest.fixture
async def kernel(ipykernel: dict) -> KernelSidecarClient:
    async with KernelSidecarClient(connection_info=ipykernel) as kernel:
        yield kernel
        # reset namespace after test is done
        await kernel.execute_request(code="%reset -f in out dhist")


@pytest.fixture(autouse=True)
def configure_logging():
    """
    Configure Structlog to log messages with `ConsoleRenderer` at the log level passed in to pytest:
     - pytest --log-level DEBUG -s
     - pytest --log-level INFO -s

    This also demonstrates roughly how an application using structlog for its own internal logging
    would configure "third party" vanilla logging (e.g. what's in kernel_sidecar) and structlog
    created logs to be formatted the same way.
    """
    # This does nothing in kernel_sidecar because we only use vanilla logging. But if you were
    # building an application that used structlog, include this so that structlog-generated
    # log messages are passed down into "vanilla logging" and configured by the logging.config
    # call further down below
    structlog.configure(
        processors=[
            structlog.stdlib.PositionalArgumentsFormatter(),
            structlog.processors.StackInfoRenderer(),
            structlog.processors.format_exc_info,
            structlog.stdlib.ProcessorFormatter.wrap_for_formatter,
        ],
        logger_factory=structlog.stdlib.LoggerFactory(),
        wrapper_class=structlog.stdlib.BoundLogger,
        cache_logger_on_first_use=True,
    )

    # shared processors to be applied to both vanilla and structlog messages
    # after each is appropriately pre-processed
    processors = [
        # log level / logger name, effects coloring in ConsoleRenderer(colors=True)
        structlog.stdlib.add_log_level,
        structlog.stdlib.add_logger_name,
        # timestamp format
        structlog.processors.TimeStamper(fmt="iso"),
        # To see all CallsiteParameterAdder options:
        # https://www.structlog.org/en/stable/api.html#structlog.processors.CallsiteParameterAdder
        # more options include module, pathname, process, process_name, thread, thread_name
        structlog.processors.CallsiteParameterAdder(
            {
                structlog.processors.CallsiteParameter.FILENAME,
                structlog.processors.CallsiteParameter.FUNC_NAME,
                structlog.processors.CallsiteParameter.LINENO,
            }
        ),
        # Any structlog.contextvars.bind_contextvars included in middleware/functions
        structlog.contextvars.merge_contextvars,
        # strip _record and _from_structlog keys from event dictionary
        structlog.stdlib.ProcessorFormatter.remove_processors_meta,
        structlog.dev.ConsoleRenderer(colors=True),
        # ^^ In prod with any kind of logging service (datadog, grafana, etc), ConsoleRenderer
        # would probably be replaced with structlog.processors.JSONRenderer() or similar
    ]

    # Configs applied to logs generated by structlog or vanilla logging
    logging.config.dictConfig(
        {
            "version": 1,
            "disable_existing_loggers": False,
            "formatters": {
                "default": {
                    "()": structlog.stdlib.ProcessorFormatter,
                    "processors": processors,
                    "foreign_pre_chain": [structlog.stdlib.ExtraAdder()],
                },
            },
            "handlers": {
                "default": {
                    "class": "logging.StreamHandler",
                    "formatter": "default",
                    "stream": "ext://sys.stdout",
                },
            },
            "loggers": {
                # "" for applying handler to "root" (all libraries)
                # you could set this to "kernel_sidecar" to only see logs from this library
                "": {
                    "handlers": ["default"],
                    "level": logging.getLogger().level,  # copy what's passed to pytest --log-level
                    "propagate": True,
                },
            },
        }
    )

    slogger = structlog.get_logger(__name__)
    slogger.info("structlog configured for structlog-generated logs and vanilla logging")
    slogger.info("structlog configured for structlog-generated logs and vanilla logging")
